\documentclass[mat1, tisk]{fmfdelo}
% \documentclass[fin1, tisk]{fmfdelo}
% Če pobrišete možnost tisk, bodo povezave obarvane,
% na začetku pa ne bo praznih strani po naslovu, …

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% METAPODATKI
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% - vaše ime
\avtor{Tjaž Eržen}

% - naslov dela v slovenščini
\naslov{Paralelizacija grafovskih algoritmov v funkcijskih programskih jezikih}

% - naslov dela v angleščini
\title{Parallelisation of Graph Algorithms in Functional Programming Languages}

% - ime mentorja/mentorice s polnim nazivom:
\mentorica{izr.~prof.~dr.~Matija Pretnar}

% - leto diplome
\letnica{2023} 



% - povzetek v slovenščini
%   V povzetku na kratko opišite vsebinske rezultate dela. Sem ne sodi razlaga
%   organizacije dela, torej v katerem razdelku je kaj, pač pa le opis vsebine.
\povzetek{TODO}

% - povzetek v angleščini
\abstract{TODO}

% - klasifikacijske oznake, ločene z vejicami
%   Oznake, ki opisujejo področje dela, so dostopne na strani https://www.ams.org/msc/
\klasifikacija{68R10, 68W10, 68N18, 68N19, 05C85}

% - ključne besede, ki nastopajo v delu, ločene s \sep
\kljucnebesede{TODO}

% - angleški prevod ključnih besed
\keywords{TODO} % angleški prevod ključnih besed


% TODO
% - angleško-slovenski slovar strokovnih izrazov
\slovar{
\geslo{funkcijsko programiranje}{računalniški koncept, znotraj katerega programe pišemo s komponiranjem in apliciranjem matematičnih funkcij}
\geslo{stranski učinki programov}{odklon med čistimi matematičnimi funkcijami ter našim programom.}
% TODO: Je vztrajno dober prevod ``persistent''?
\geslo{Vztrajna podatkovna struktura}{TODO}
% TODO: Je minljivo dober prevod ``ephemeral''?
\geslo{Minljiva podatkovna struktura}{TODO}
\geslo{high performance computing}{Visokozmožnostno računanje}
\geslo{domains}{domene}
\geslo{parallel tasks}{vzporedne naloge}
\geslo{task collections}{zbirke opravil}
\geslo{parallel computation patterns}{vzorci vzporednega računanja}
\geslo{synchronization primitives}{sinhronizacijski mehanizmi}
\geslo{load balancing}{Izravnavanje obremenitve}
\geslo{high-level}{visokonivojski}
}

% - ime datoteke z viri (vključno s končnico .bib), če uporabljate BibTeX
% \literatura{literatura.bib}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DODATNE DEFINICIJE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% naložite dodatne pakete, ki jih potrebujete
\usepackage{algpseudocode}  % za psevdokodo
\usepackage{algorithm}      % za algoritme
\usepackage{algorithmicx}
\usepackage{hyperref}
\usepackage{listings}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    citecolor=red
}

% Set the font size for all listings
\lstset{basicstyle=\footnotesize\ttfamily}

\algnewcommand\algorithmicto{\textbf{to}}
\algnewcommand\algorithmicin{\textbf{in}}
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algrenewtext{For}[3]{\algorithmicfor\ #1 $\gets$ #2\ \algorithmicto\ #3\ \algorithmicdo}
\algdef{S}[FOR]{ForEach}[2]{\algorithmicforeach\ #1\ \algorithmicin\ #2\ \algorithmicdo}


\floatname{algorithm}{Algoritem}
\renewcommand{\listalgorithmname}{Kazalo algoritmov}

\newcommand{\R}{\mathbb R}
\newcommand{\N}{\mathbb N}
\newcommand{\Z}{\mathbb Z}
\newcommand{\C}{\mathbb C}
\newcommand{\Q}{\mathbb Q}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ZAČETEK VSEBINE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\section{Uvod}

Grafovski algoritmi so dan danes ključni pri modeliranju širokega nabora vsakdanjih problemov: 
Igrajo pomembno vlogo pri modeliranju družbenih ter računalniških omrežjih, z njimi pa se prav tako razrešujejo problemi na področjih računalniške komunikacije ter podatkovne analitike. 
Splošno, z grafi lahko abstrahiramo kakršno koli množico odnosov med danimi entitetami, vse od računanja razdalj med mesti, pa do računanje vodnega pretoka od enega kraja do drugega.

Ker kompleksnost grafov raste nelinearno z večanjem podatkov, z njihovim računanjem ter procesiranjem pogosto trčimo ob računsko prezahtevno oviro.
Načinov za reševanje tega je več, pogosto pa je ena izmed najpogostejših ozkih grl to, da našega programa nismo napisali paralelno ter s tem izkoristili celotne kapacitete računalnika, 
temveč smo naš program poganjali zgolj na enem jedru. 
Posledično je paralelizacija tovrstnih algoritmov v zadnjih letih postala zanimiva in aplikativna raziskovalna tema. 
V svoji diplomski nalogi se bom tako ukvarjal z paralelizacijo grafovksih algoritmov.

Funkcijski programski jeziki zagotavljajo matematične abstrakcije na višjem nivoju, kot so jih to sposobni navadni imperativni programski jeziki, kot so na primer Python, C++ in Java. 
Ena izmed prednosti funkcijskih programskih jezikov je, da omogočajo deklarativno programiranje, kar jih naredi bolj paralelizabilne (več o tem v nadaljevanju). 
Tako me je zanimanje za matematične grafe, algoritme in funkcijske jezike pripeljalo v združevanje vseh teh tem hkrati: 
V svoji diplomski nalogi se bom zato osredotočil na \textit{paralelizacijo grafovskih algoritmov v funkcijskih programskih jezikih}.

\begin{definicija}
  \textbf{Deklarativni programski jezik} je vrsta programskega jezika, kjer razvijalec opišie kaj naj program stori, namesto kako naj to stori. Programi so tipično strukturirani kot nizi deklaracij, 
  ki določajo razmerja in omejitve med med različnimi entitetami znotraj problema. Nasprotno, \textbf{imperativni programski jezik} je vrsta programskega jezika, kjer programer navede zaporedje ukazov,
  ki naj jih računalnik izvrši za rešitev problema.
\end{definicija}

Vzporednost na nivoju pomnilnika je moč doseči na dva načina: 
Tako, da je pomnilnik vsem računalniškim jedrom skupen, ali pa da je pomnilnik \textit{porazdeljen}. 
V tej diplomski nalogi se bom osredotočal na sisteme s skupnim pomnilnikom. 
V tej diplomski nalogi se bom osredotočal zgolj na sisteme s skupnim pomnilnikom ter porazdeljeno procesorsko močjo.

Vse več funkcijskih programskih jezikov, kot so na primer Scala, F\# ter Haskell ima implementirane knjižnice in ogrodja za paralelizacijo grafovskih algoritmov:
\begin{itemize}
    \item knjižnica \textit{Graphalyze} v Haskellu zagotavlja vzporedne algoritme za najkrajšo pot ter iskanje krepko povezanih komponent.
    \item \textit{GraphX} v Scali ponuja implementacijo paralelnega Googlovega PageRank algoritma.
    \item \textit{Alea.cuBase} nam ponuja osnovne paralelne algoritme v jeziku F\#.
\end{itemize}

Od konca lanskega leta pa imamo nov funkcijski programski jezik, ki je postal ``multicore'' - to je OCaml, ki se med drugim poučuje na naši fakulteti v sklopu računalniško-orientiranih predmetov. 
Zato sem to priložnost izoristil, da svoje računalniške programe pišem v tem funkcijskem jeziku. 
V tej diplomski naloge se bom tako spustil v tovrstne knjižnice v funkcijskih jezikih, ki že obstajajo, 
pregledal novejše raziskave kar se tiče grafovskih algoritmov v imperativnih jezikih, to prevedel v deklarativni jezik ter vse to skupaj povezav v zaključeno celovito knjižnico v OCamlu.

\section{Kratek uvod v funkcijsko programiranje}

\subsection{Zakaj funkcijski programski jeziki}

\begin{definicija}
\textbf{Stranski učinki} so v programiranju kakršen koli odklon med čistimi matematičnimi funkcijami ter našim programom.
\end{definicija}

\begin{definicija}
  \textbf{Funkcijsko programiranje} je računalniški koncept, znotraj katerega programe pišemo komponiranjem in apliciranjem matematičnih funkcij. 
  .
\end{definicija}

Že po definiciji je moč čutiti, da bo taka vrsta programov v splošnem bolj podobna pisanju čistih matematičnih funkcij. Posledično programiranje take vrste uporabnika preko zasnove samega jezika
spodbudi, piše programe z manj stranskimi učinki.

Programiranje take vrste uporabnika preko zasnove samega jezika spodbudi, da piše t.i. programe brez stranskih učinkov oz. jih omeji kakor se le da. 
Primer stranskega učinka bi bilo spreminjanje uporabniškega pomnilnika, ali pa branje tekstovnih datotek.

Kot rečeno, v splošnem se stranskim učinkov želimo izogniti, saj pogosto zbegajo tako razvijalca kot tudi uporabnika: 
Sorazvijalcu zmanjšajo preglednost naše kode ter privedejo do bolj pogostih napak, iz uporabniškega stališča pa se kakšen podatek v ozadju nehote spremeni, kar uporabnika pogosto zbega. 
Tiste dele kode, ki pa stranske učinke imajo, pa izoliramo v smislu da dodatno ne počnejo še drugih čistih matematičnih operacij.

% TODO: Dodaj code snippet, kjer pokažeš, zakaj stranski učinki niso zaželjeni.

Zadnjih par let funkcijski programski jeziki zaradi svojih lastnosti pridobivajo na popularnosti. 
Zaradi zasnove funkcijskih programskih jezikov so tovrstni programi tipično lepše razdeljeni v manjše kose kode, znotraj ima vsak kot kode natanko eno funkcijo, 
kar omogoči lažjo uporabo iste programske kode na več različnih problemih. 
Zaradi takih učinkov ter drugih razlik, ki ločijo funkcijske ter imperativne jezike (npr. preverjanje tipov pred izvajanjem programa) pa je naš program prav tako precej lažje testirati, razhroščevati in vzdrževati. 
Funkcijski programer se pogosto pošali, da mu program njegovo napako sporoči že preden je program sploh zagnal. 
Tako je uporabnik ``prisiljen'' pisati bolj robustne ter zanesljive programe, manj izpostavljene potencialnim napakam ter sesutjem.

Zadnja prednost, ki bi jo izpostavil, je razlika v hitrosti funkcijskih jezikov - le-ti so po eni strani precej bolj ekpresivni od nižjenivojskih imperativnih jezikov (C++, C) 
ter le malo počasnejši kar se tiče izvajanja, po drugi strani pa precej  hitrejši od visokonivojskih programskih jezikov (Python, Ruby, Java), 
s čimer imajo dobro uporabno nišo v industriji, kjer sta važna tako hitrost kot ekspresivnost jezika (npr. uporaba takih jezikov za visoko-frekvenčno trgovanje s finančnimi instrumenti).

Kot že omenjeno v uvodu, pa funkcijski jeziki prav tako omogočajo lažjo sočasnost ter paralelizabilnost programa. 
Vse to funkcijske jezike naredi primerne za t.i. \textit{visoko performančne sisteme z večnitinimi programi} (ang. high performance computing).

% TODO: Dodaj še kaj o paralelizabilnosti tukajle.

\subsection{Funkcijske podatkovne strukture}

Ko potrebujem npr. implementacijo vrste s prednostjo v Pythonu, je pogosto dovolj, da v splošnem učbeniku najdem njeno implementacijo ter to prepišem. 
Razvijalci, ki pa svojo kodo pišejo v funkcijskih programskih jezikih, pa pogosto te sreče nimajo. 
Razloga sta dva: Prvi bi bil, da funkcijski jeziki niso tako razširjeni kot imperativni, drugi pa je, da se funkcijski jeziki med sabo bolj razlikujejo kot se med sabo razlikujejo imperativni. 
Poljubno psevdokodo, napisano v imperativnem smislu, je lažje prirediti v Python, kot pa je npr. poljubno psevdokodo, napisano v funkcijskem smislu prirediti v na primer OCaml.

\begin{definicija}
V splošnem podatkovne strukture delimo na dve skupini:
\begin{itemize}
  \item Podatkovna struktura je \textbf{vztrajna}, če lahko vidimo njeno zgodovino spreminjanja. Taka podatkovna struktura hrani svoje prejšne verzije.
  \item Podatkovna struktura je \textbf{minljiva}, je podatkovna struktura, ki ne pomni svojih prejšnih verzij.
\end{itemize}
\end{definicija}

Funkcijski programski jeziki imajo zanimivo lastnost, da so vse podatkovne strukture avtomatsko \textit{vztrajne}, 
medtem ko je v imperativnih programskih jezikih vztrajne podatkovne strukture tipično težje implementirati, prav tako pa so asimptotsko počasnejše kot ``minljive'' podatkovne strukture. 
Prednost vztrajnih podatkovnih struktur očitno ta, da lahko dostopamo do svojih prejšnjih različic, prednost minljivih struktur pa je, da da so hitrejše na pram vztrajnih. 
Posledično so v splošnem podatkovne strukture v funkcijskih jezikih asimptotsko počasnejše kot pri imperativnih jezikih.

% TODO (kasneje): Podaj primer podatkovne strukture, ki se je na funkcijski način ne da učinkovito implementirati.
Še ena slabost podatkovnih struktur v funkcijskih jezikih je, da se nekaterih podatkovnih struktur preprosto ne da učinkovito implementirati na funkcijski način.

V nadaljevanju dokumenta se bom najprej posvetil vprašanju, kako graf v funkcijskih jezikih sploh predstavimo, nato pa se bom lotil algoritmov ter podatkovnih struktur na grafih.


\section{Prestavitev grafa v funkcijskih jezikih}

\textbf{TODO}

\pagebreak

\section{Paralelizacija}

\subsection{Pregled OCamlove knjižnice \textit{Domainslib}}

\href{https://github.com/ocaml-multicore/domainslib}{Domainslib} je sočasna programska knjižnica za OCaml, 
ki nam omogoča paralelizacijo na nivoju procesorja.
Ponuja nam niz abstrakcij in orodij za pisanje vzporednih in sočasnih programov. 
Zgrajena je na t.i. domenah (ang. domains). To so lahke niti, vgrajene v OCaml.

S prihodom nove različice OCaml 4.12, je Domainslib postal del standardne knjižnice OCaml, z verzije 5.0.0 pa se je ta knjižnica
še precej okrepila na svojih sposobnostih ter računskih zmožnostih.

Tukaj povzamem glavne koncepte Domainsliba, ki jih bom uporabil v svoji diplomski nalogi:

\begin{enumerate}
  \item Domene (ang. domains) so niti, ki nam zagotavljajo sočasnost v OCaml-u. 
        Po svoji zasnovi so visokonivojske ter imajo nizke stroške dodatne računske obremenitve, 
        kar omogoča ustvarjanje velikega števila sočasnih nalog. Novo domeno ustvarimo z ukazom ~\texttt{Domainslib.make}.
  \item Paralelne naloge (ang. parallel tasks): Knjižnica nam ponuja preproste funkcije za ustvarjanje in upravljanje z vzporednimi nalogami.
        Naloge so delovne enote, ki se lahko izvajajo hkrati na različnih domenah.
        Ustvarijo se s funkcijo ~\texttt{Domainslib.Task.async}, na njihovo dokončanje pa se počaka z uporabo ~\texttt{Domainslib.Task.await}
  \item Zbirke opravil (ang. task collections): Knjižnica nam ponuja zbirke opravil, ki so podobne paralelnim nalogam, 
        le da lahko v njih shranimo več nalog hkrati. Zbirke opravil so lahko uporabne, kadar želimo ustvariti več nalog hkrati, 
        vendar pa ne želimo ustvariti toliko domen, kot je nalog.
  \item Vzorci vzporednega računanja (ang. parallel computation patterns), ki so pogosto uporabni pri vzporednem programiranju.
        Na primer, vzorec ~\texttt{Domainslib.Parallel.map} nam omogoča vzporedno preslikavo funkcije na seznam elementov. 
        Podobno nam vzorec ~\texttt{Domainslib.Parallel.reduce} omogoča vzporedno zmanjševanje seznama elementov, 
        z vzorcem ~\texttt{Domainslib.Parallel.stable\_sort} vzporedno uredimo seznam elementov, 
        z ukazom ~\texttt{Domainslib.Parallel.For} pa vporedno poženemo for zanko. Vse to nam precej olajša delo, če lahko večji kos računalniške naloge
        razdelimo na manjše kose, ki jih lahko izvajamo vzporedno že preko vgrajenih funkcij.
  \item Sinhronizacijski mehanizmi (ang. synchronization primitives): Knjižnica nam ponuja sinhronizacijske pritive, ki nam omogočajo sinhronizacijo med domenami.
        Na primer, sinhronizacijski mehanizem ~\texttt{Domainslib.Sync} nam omogoča sinhronizacijo med domenami, 
        sinhronizacijski primitiv ~\texttt{Domainslib.Sync\_event} pa nam omogoča sinhronizacijo med domenami preko dogodkov.
  \item Izravnavanje obremenitve (ang. load balancing): Domainslib nam ponuja orodja za izravnavanje obremenitve, 
        ki nam omogočajo, da se obremenitev med domenami porazdeli čim bolj enakomerno.
\end{enumerate}

Na splošno knjižnica Domainslib poenostavlja postopek pisanja vzporednih in sočasnih programov v OCamlu. 
Zagotavlja nam visokonivojski (ang. high-level) vmesnik za upravljanje nalog, usklajevanje sinhronizacije in izkoriščanje vzporednosti, 
kar olajša izkoriščanje celotnega potenciala večjedrnih procesorjev ter doseganje boljše zmogljivosti.





\subsection{Paralelizacija 101: Računanje Fibonaccijevih števil}




\end{document}
